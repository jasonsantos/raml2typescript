const raml2obj = require("raml2obj");
const nunjucks = require("nunjucks");
const package = require("./package.json");

const indent = (n = 0) => "  ".repeat(n);

const camel = s => s.substr(0, 1).toUpperCase() + s.substr(1);

const loadEnums = (enums, obj) => {
  if (obj.enum) {
    enums[camel(obj.name)] = obj.enum;
  }
  const children = obj.properties || (obj.items && obj.items.properties);
  if (children) {
    for (key in children) {
      loadEnums(enums, children[key]);
    }
  }
  return enums;
};

const renderEnum = (name, list) => {
  return (
    "\nenum " +
    name +
    " {\n" +
    list.map(i => "  " + i + ' = "' + i + '"').join(",\n") +
    "\n};\n"
  );
};

const generateEnums = obj =>
  obj.types &&
  Object.keys(obj.types)
    .map(k => obj.types[k])
    .reduce(loadEnums, {});

const generateInserts = obj => {
  const inserts = ["** generated by raml2typescript"];
  return (
    inserts.join("\n") +
    "\n" +
    Object.keys(obj.enums)
      .map(e => renderEnum(e, obj.enums[e]))
      .join("\n")
  );
};

function render(source, config, options) {
  config = config || {};
  config.indent = config.indent || indent;
  config.raml2TypescriptVersion = package.version;
  return raml2obj.parse(source).then(ramlObj => {
    ramlObj.config = config;
    ramlObj.enums = generateEnums(ramlObj);
    ramlObj.camel = camel;
    ramlObj._inserts = generateInserts(ramlObj);
    ramlObj.isNamedType = function(type) {
      if (typeof type === "object") {
        return ramlObj.types && ramlObj.types[type.name];
      }
      return type && type.indexOf("{") === -1 && type.indexOf("<") === -1;
    };
    console.log("const raml =", JSON.stringify(ramlObj));
    return nunjucks.configure("templates").render("type.nunjucks", ramlObj);
  });
}

module.exports = {
  render
};

if (require.main === module) {
  console.error(
    "This script is meant to be used as a library. You probably want to run bin/raml2typescript if you're looking for a CLI."
  );
  process.exit(1);
}
